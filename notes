BT:
    def __init__(self):
        [...]
        self.publish('bt_ready')

    def on_exit(self):
        [...]

    def run(self):
        [...]
        while not self.end:
            [...]

            elif alert.what() == "torrent_update_alert":
                self.publish('publish_shares')

            elif alert.what() == "state_update_alert":
                self.publish('publish_shares')

            elif alert.what() == "file_error_alert":
                [...]
                self.publish('publish_shares')

            elif alert.what() == "portmap_alert":
                [...]
                self.publish('set_port', alert.external_port)

            elif alert.what() == "metadata_received_alert":
                [...]
                self.publish('publish_shares')

    def on_add_peer(self, infohash, peer_address, peer_port):
        [...]

    def on_add_hash(self, sha_hash, save_path):
        [...]

    def on_add_torrent(self, torrentfilepath, save_path):
        [...]
        self.publish('publish_shares')

    def on_add_torrent_by_info(self, torrentinfo, save_path, resumedata=None):
        [...]
        self.publish('publish_shares')

    def on_generate_torrent(self, path):
        [...]

    def on_del_torrent(self, handle):
        [...]


JSONRPC:
    @jsonrpc.method('Api.exit')
    def safe_exit():
        publish('exit')

    @jsonrpc.method('bt.add_torrent_by_hash', mlink='', save_path=None)
    def add_torrent_by_hash(hash, save_path):
        logger.info('adding hash %s to torrents' % hash)
        publish('add_hash', hash, save_path)

XMPP:
    def start(self, event):
        self.get_roster()
        self.publish('publish_shares')

    def on_publish_shares(self):

    def on_shares_publish(msg):

    def on_exit(self):